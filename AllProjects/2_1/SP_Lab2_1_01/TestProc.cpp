#include <windows.h>
#include <tchar.h>


LRESULT CALLBACK SimWndProc(HWND, UINT, WPARAM, LPARAM); // прототип оконной функции
														 // cообщение 


int APIENTRY _tWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,
	LPTSTR lpszCmdLine, int nCmdShow) //точка входа в программу
									  //главная функция возращает системе целое значение
									  //WINAPI и APIENTRY - определяет порядок передачи параметров при вызове функции
									  //handle - указатель на блок памяти, где размещен объект
									  //void* -> HANDLE -> HINSTANCE и h в венгерской нотации
									  //hInstance - указатель на экземпляр программы
									  //hPrewInstance - раньше указывал на предыдущий экземпляр программы, а в win32 оставлен для совместимости с предыдущими версиями
									  //lpszCmdLine - указатель на командную строку, которая определяет параметры запуска
									  //nCmdShow - в каком виде появляется запускаемое окно (10 констант, определенных в системе)
									  //например, SW_SHOWNORMAL - одна из констант, за которой скрывается числовое значение
{
	WNDCLASSEX wc; //структура окна, хранящая его характеристики
	MSG msg;
	HWND hWnd;

	//Создание кисти Привер Москалёва на 2й лекции
	COLORREF clr;
	clr = RGB(192, 192, 192); // цвет заливки
	HBRUSH hBr;
	hBr = CreateSolidBrush(clr); // тип заливки 

								 /* Заполняем структуру окна типа WNDCLASS */
	memset(&wc, 0, sizeof(WNDCLASSEX));//заполняем структуру окна нулями
	wc.cbSize = sizeof(WNDCLASSEX);//размер структуры
	wc.lpszClassName = TEXT("SimpleClassName");//имя класса окна
	wc.lpfnWndProc = SimWndProc;//указатель на оконную процедуру, с которой связано окно (она обрабатывает все поступающие сообщения)
	wc.style = CS_VREDRAW | CS_HREDRAW;//UINT - стиль окна, можно комбинировать стили (побитовое сложение и умножение)
	wc.hInstance = hInstance;//указатель на экземпляр программы
	wc.hIcon = LoadIcon(NULL, MAKEINTRESOURCE(IDI_ASTERISK));//хэндл иконки (указатель на нее) - если первый параметр нуль, то используется системная иконка, иначе нужно указывать хэндл программы
																   //wc.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);//чем закрашен фон окна
	wc.hbrBackground = hBr;
	wc.lpszMenuName = NULL; //указатель на строку, содержащую имя меню для программы
	wc.cbClsExtra = 0;//размер резервируемой памяти для структуры класса (используется редко)
	wc.cbWndExtra = 0;//размер резервируемой памяти для структуры окна (используется редко)


					  /* Регистрация класса окна и сообщение об ошибке в случае неудачи */
	if (!RegisterClassEx(&wc))
	{
		MessageBox(NULL, TEXT("Ошибка регистрации класса окна!"),
			TEXT("Ошибка"), MB_OK | MB_ICONERROR);//используется окно предопределенного класса для вывода сообщения об ошибке с кнопкой OK и иконкой ошибки
		return FALSE;
	}

	/*  Создание окна программы на основе зарегистрированного класа */
	//функция CreateWindowEx возвращает хэндл созданного окна или нуль 
	hWnd = CreateWindowEx(NULL, //Определяет расширенный стиль создаваемого окна. Этот параметр может состоять из одного или нескольких значений
		TEXT("SimpleClassName"), //имя класса окна
		TEXT("TestProc"), //текст для заголовка окна
		WS_OVERLAPPEDWINDOW, //индивидуальный стиль окна, можно комбинировать стили (побитовое сложение и умножение)
		CW_USEDEFAULT, CW_USEDEFAULT, //определяют положение окна на экране - измеренные в пикселях отступы
		CW_USEDEFAULT, CW_USEDEFAULT,//верхнего левого угла окна от лекого края, верхней границы, а также ширину и высоту
				 //CW_USEDEFAULT допускается только для окон со стилем WS_OVERLAPPEDWINDOW
		NULL, NULL, //хэндл родительского окна //хэндл меню текущего окна
		hInstance, NULL); //хэндл программы //указатель на структуру с дополнительными данными (используется не часто)

						  /*  Сообщение об ошибке, если окно не создано */
	if (!hWnd)
	{
		MessageBox(NULL, TEXT("Окно не создано!"),
			TEXT("Ошибка"), MB_OK | MB_ICONERROR);
		return FALSE;
	}


	/* Отображение созданного окна на экране */
	ShowWindow(hWnd, nCmdShow); //хэндл созданного окна //в каком виде появляется запускаемое окно (10 констант, определенных в системе), как и с WinMain
	UpdateWindow(hWnd); //перерисовка рабочей области окна (за нее отвечает программа)
						//перерисовка атрибутов окна осуществляет сама система


						/* Цикл обработки ивентов (сообщений, посылаемых окну) - их содержание определяется структурой tagMSG из заголовочого файла */
	while (GetMessage(&msg, NULL, 0, 0)) //функция GetMessage выбирает сообщение из очереди, пока они не закончатся
										 //первый параметр - структура, которая получает информацию о сообщении
										 //второй параметр - хэндл дочернего окна, созданного программой
										 //два оставшихся параметра - интервал сообщений (фильтрация по нижней и верхней границе)
										 //функция всегда возвращает ненулевое значение, за исключением случая WM_QUIT - выход из программы

	{
		DispatchMessage(&msg); //посылает каждое сообщение соответствующей оконной процедуре
	}

	return msg.wParam;
}


/* Оконная процедура */
LRESULT CALLBACK SimWndProc(HWND hWnd, UINT msg,
	WPARAM wParam, LPARAM lParam)
{
	HDC hDC;
	switch (msg)
	{

	case WM_PAINT:    // Вывод при обновлении окна, каждое окно должно обрабатывать это сообщение, иначе оно не сможет восстановиться при изменении
		PAINTSTRUCT ps;
		hDC = BeginPaint(hWnd, &ps); // Получение контекста для обновления окна 
		TextOut(hDC, 10, 10, TEXT("Hello, World!"), 13); // Вывод в контекст
														 //HDC hdc - дескриптор DC
														 //int nXStart - x-координата начальной позиции
														 //int nYStart - y-координата начальной позиции
														 //LPCTSTR lpString - строка символов
														 //int cbString- число символов
		EndPaint(hWnd, &ps); // Завершение обновления окна
		break;

	case WM_DESTROY:  // Завершение работы приложения
		PostQuitMessage(0); //функция отправляет приложение сообщение WM_QUIT, которое завершает цикл обработки сообщений
		break;

	default: // Вызов "Обработчика по умолчанию"
		return(DefWindowProc(hWnd, msg, wParam, lParam));//все необработанные сообщения передаются в функцию обработки по умолчанию - Default Window Procedure
														 //остальные сообщения, которые нуждаются в нестандартной обработке, обрабатываются внутри switch
	}

	return FALSE;// Для ветвей с "break"
}
